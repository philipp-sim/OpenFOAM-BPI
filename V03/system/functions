/*--------------------------------*- C++ -*----------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     | Website:  https://openfoam.org
    \\  /    A nd           | Version:  12
     \\/     M anipulation  |
\*---------------------------------------------------------------------------*/
FoamFile
{
    format      ascii;
    class       dictionary;
    location    "system";
    object      functions;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

//#includeFunc scalarTransport(T, diffusivity=constant, D = 0.01)

CO2Eqn
{
    type            coded;
    libs ( "libutilityFunctionObjects.so" );
    writeControl    writeTime;

	codeInclude
    #{

		#include "volFields.H"
		#include "fvc.H"
		#include "fvm.H"
		#include "fvModels.H"
		#include "fvConstraints.H"

	#};

    codeExecute
    #{  

		auto ensureFieldExists = [&](const word& name, const dimensionSet& dims)
		{
			if (!mesh().objectRegistry::foundObject<volScalarField>(name))
			{
				Info << "Creating " << name << " field" << endl;
				auto* ptr = new volScalarField(
					IOobject(name, mesh().time().name(), mesh(), IOobject::READ_IF_PRESENT, IOobject::AUTO_WRITE),
					mesh(),
					dimensionedScalar(name, dims, 0.0)
				);
				mesh().objectRegistry::store(ptr);
			}
		};

		IOdictionary physicalProperties
		(
			IOobject
			(
				"physicalProperties",
				mesh().time().constant(),
				mesh(),
				IOobject::MUST_READ,
				IOobject::NO_WRITE
			)
		);

		ensureFieldExists("CO2", dimensionSet(0,0,0,0,0,0,0));
        ensureFieldExists("Y_CO2", dimensionSet(0,0,0,0,0,0,0));
		//ensureFieldExists("CO2relativdensity", dimensionSet(1,-3,0,0,0,0,0));
		//volScalarField& CO2relativdensity = mesh().lookupObjectRef<volScalarField>("CO2relativdensity");
		volScalarField& CO2 = mesh().lookupObjectRef<volScalarField>("CO2");
        volScalarField& Y_CO2 = mesh().lookupObjectRef<volScalarField>("Y_CO2");
		const volScalarField& T = mesh().lookupObject<volScalarField>("T");
        const volVectorField& U = mesh().lookupObject<volVectorField>("U");
		const volScalarField& rho = mesh().lookupObject<volScalarField>("rho");
		const surfaceScalarField& phi = mesh().lookupObject<surfaceScalarField>("phi");
		const Foam::fvModels& fvModels(Foam::fvModels::New(this->mesh()));
		const Foam::fvConstraints& fvConstraints(Foam::fvConstraints::New(this->mesh()));
		const dimensionedScalar D_CO2(physicalProperties.lookup("D_CO2"));

		const dimensionedScalar P("P", dimensionSet(1, -1, -2, 0, 0, 0, 0), 101325);// Pa standard atmosphere pressure
		const dimensionedScalar Rm("Rm", dimensionSet(1, 2, -2, -1 , -1, 0, 0), 8.314);// J/(mol*K) universal gas constant
		const dimensionedScalar M_C("M_C", dimensionSet(1, 0, 0, 0, -1, 0, 0), 12.0107e-3); // kg/mol
		const dimensionedScalar M_N("M_N", dimensionSet(1, 0, 0, 0, -1, 0, 0), 14.0067e-3); // kg/mol
		const dimensionedScalar M_O("M_O", dimensionSet(1, 0, 0, 0, -1, 0, 0), 15.9994e-3); // kg/mol
		const dimensionedScalar M_Ar("M_Ar", dimensionSet(1, 0, 0, 0, -1, 0, 0), 39.948e-3); // kg/mol 
        
        

		dimensionedScalar M_CO2 = M_C + 2 * M_O; // kg/mol
		volScalarField M_Air = M_N * 0.78 + M_O * (0.21 - CO2/1e6) + M_Ar * 0.01 + M_CO2 * (CO2/1e6); // kg/mol
		volScalarField Mol_co2_part =  M_CO2 * (CO2 / 1e6); // kg/mol Part from M_Air
		tmp<volScalarField> rho_mix = (M_Air * P) / (Rm * T); // kg/m³ mixture

        //Y_CO2 = ((CO2/1e6)*M_CO2)/((CO2/1e6)*M_CO2 + (1-CO2/1e6)*M_Air); // mass fraction of CO2 in the mixture
		//tmp<volScalarField> rho_co2 = (M_CO2 * P) / (Rm * T); // kg/m³ CO2
		//CO2relativdensity = (P * Mol_co2_part) / (Rm * T); // kg/m³ CO2 mass from mixture 

        volScalarField rho_co2
        (
            IOobject
            (
                "rho_co2",
				mesh().time().constant(),
				mesh(),
                IOobject::NO_READ,
                IOobject::NO_WRITE
            ),
            (M_CO2 * P) / (Rm * T)
        );

        surfaceScalarField phi_co2 = fvc::interpolate(rho_co2) * fvc::interpolate(U) & mesh().Sf(); // phi = rho_humair * U
        // phi_co2 problematic bec. mass flux is not mass constant

        //surfaceScalarField phi_diff("phi_diff", phi_co2 - phi);
        //scalar diffNorm = gSum(phi_diff);
        //Info << "Flux magnitude difference between phi_co2 and phi = " << diffNorm << endl;
        //Info << "Total flux magnitude difference between phi_co2 and phi = " << diffNorm << endl;

		fvScalarMatrix CO2Eqn =
			fvm::ddt(rho_co2, Y_CO2)
            + fvm::div(phi_co2, Y_CO2,"div(phi,CO2)")
            - fvm::laplacian(rho_co2*D_CO2, Y_CO2);
            //== fvModels.source(rho_co2, Y_CO2);
			
		fvConstraints.constrain(CO2Eqn);
		CO2Eqn.relax();
		CO2Eqn.solve();
		fvConstraints.constrain(Y_CO2);
        //scalar totalMassCO2 = gSum(Y_CO2 * rho_co2 * mesh().V());
        //Info << "Total CO2 mass = " << totalMassCO2 << endl;


        //Y_CO2 = ((CO2/1e6)*M_CO2)/((CO2/1e6)*M_CO2 + (1-CO2/1e6)*M_Air);
        CO2 = (Y_CO2*M_Air) / (M_CO2*(1-Y_CO2) + Y_CO2*M_Air) * 1e6; // molar fraction of CO2 in the mixture * 1e6 to get ppm
        CO2.correctBoundaryConditions();


		const label nCells = returnReduce(CO2.internalField().size(), sumOp<label>());

		if (mesh().time().writeTime())
		{
			Info << "D_CO2: " << D_CO2.value() << endl;
			Info << "Cell count: " << nCells << endl;
			Info << "CO2 avg: " << gSum(CO2) / nCells << endl;
            Info << "Y_CO2 avg: " << gSum(Y_CO2) / nCells << endl;
		}
    #};
}




// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //



DataExtract
{
    type    coded;
    libs    ("libutilityFunctionObjects.so");
    name    DataExtract;

    codeInclude
    #{
        #include "fvMesh.H"
        #include "volFields.H"
        #include "OSspecific.H"
        #include "IOobjectList.H"
        #include "OFstream.H"
        #include <thread>
        #include <chrono>
    #};

    codeLibs
    #{
        -lOpenFOAM -lfiniteVolume
    #};

    codeExecute
    #{
        auto extractFieldData = [&](const word& fieldName, const vector& lower, const vector& upper, const scalar& roundedTime)
        {
            const fvMesh& mesh = this->mesh();
            const pointField& centres = mesh.C();
            bool isParallel = (Pstream::parRun() && Pstream::nProcs() > 1);

            fileName mergedDir = mesh.time().globalPath() / "postProcess" / fieldName;
            mkDir(mergedDir);
            fileName mergedOutputPath = mergedDir / "Data";
            if (roundedTime == 0 && isFile(mergedOutputPath))
            {
                std::remove(mergedOutputPath.c_str());
            }

            fileName procOutputPath;
            if (isParallel)
            {
                procOutputPath = mesh.time().path() / (fieldName + "_" + Foam::name(roundedTime) + "_proc" + Foam::name(Pstream::myProcNo()));
            }
            else
            {
                procOutputPath = mergedDir / Foam::name(roundedTime);
            }

            if (isFile(procOutputPath))
            {
                std::remove(procOutputPath.c_str());
            }

            std::ostringstream buffer;

            if (mesh.foundObject<volScalarField>(fieldName))
            {
                const volScalarField& field = mesh.lookupObject<volScalarField>(fieldName);
                buffer << "x,y,z," << fieldName << "\n";

                forAll(field, cellI)
                {
                    const point& p = centres[cellI];
                    if ((p.x() >= lower.x() && p.x() <= upper.x()) &&
                        (p.y() >= lower.y() && p.y() <= upper.y()) &&
                        (p.z() >= lower.z() && p.z() <= upper.z()))
                    {
                        scalar val = field[cellI];
                        buffer << p.x() << "," << p.y() << "," << p.z() << "," << val << "\n";
                    }
                }
            }
            else if (mesh.foundObject<volVectorField>(fieldName))
            {
                const volVectorField& field = mesh.lookupObject<volVectorField>(fieldName);
                buffer << "x,y,z," << fieldName << "_x," << fieldName << "_y," << fieldName << "_z," << fieldName << "_mag\n";

                forAll(field, cellI)
                {
                    const point& p = centres[cellI];
                    if ((p.x() >= lower.x() && p.x() <= upper.x()) &&
                        (p.y() >= lower.y() && p.y() <= upper.y()) &&
                        (p.z() >= lower.z() && p.z() <= upper.z()))
                    {
                        const vector& val = field[cellI];
                        buffer << p.x() << "," << p.y() << "," << p.z() << ","
                               << val.x() << "," << val.y() << "," << val.z() << ","
                               << mag(val) << "\n";
                    }
                }
            }
            else
            {
                Info << "Field " << fieldName << " not found or unsupported type." << endl;
                return true;
            }

            std::ofstream output(procOutputPath.c_str());
            output << buffer.str();
            output.close();

            Info << fieldName << " values written to " << procOutputPath << endl;

            if (isParallel)
            {
                scalar dummy = 0;
                Pstream::scatter(dummy);

                if (Pstream::myProcNo() == 0)
                {
                    std::ofstream merged(mergedOutputPath.c_str(), std::ios::app);
                    merged << "Timestep" << Foam::name(roundedTime) << "\n";

                    for (int procNo = 0; procNo < Pstream::nProcs(); ++procNo)
                    {
                        fileName procDir = mesh.time().globalPath() / ("processor" + Foam::name(procNo));
                        fileName filePath = procDir / (fieldName + "_" + Foam::name(roundedTime) + "_proc" + Foam::name(procNo));
                        const int maxWaitMs = 1000;
                        bool fileAvailable = false;
                        for (int waitMs = 0; waitMs < maxWaitMs; ++waitMs)
                        {
                            if (isFile(filePath))
                            {
                                fileAvailable = true;
                                break;
                            }
                            std::this_thread::sleep_for(std::chrono::milliseconds(1));
                        }

                        if (fileAvailable)
                        {
                            std::ifstream fin(filePath.c_str());
                            std::string line;
                            bool firstLine = true;
                            while (std::getline(fin, line))
                            {
                                if (firstLine) { firstLine = false; continue; }
                                merged << "\"" << line << "\"\n";
                            }
                            fin.close();
                            std::remove(filePath.c_str());
                        }
                        else
                        {
                            Info << "Missing file from processor" << procNo << ": " << filePath << endl;
                        }
                    }

                    merged.close();
                    Info << "Appended data block for time " << roundedTime << " to " << mergedOutputPath << endl;
                }
            }
            else
            {
                std::ifstream fin(procOutputPath.c_str());
                std::ofstream merged(mergedOutputPath.c_str(), std::ios::app);
                std::string line;
                bool firstLine = true;

                merged << Foam::name(roundedTime) << "\n";

                while (std::getline(fin, line))
                {
                    if (firstLine) { firstLine = false; continue; }
                    merged << "\"" << line << "\"\n";
                }

                fin.close();
                merged.close();
                std::remove(procOutputPath.c_str());
                Info << "Appended data block for time " << roundedTime << " to " << mergedOutputPath << " (serial mode)" << endl;
            }

            return true;
        };

        static scalar lastWrittenTime = -1;
        scalar writeInterval = 1; 
        scalar time = mesh().time().value();
        int precision = std::max(0, int(-std::floor(std::log10(writeInterval) + SMALL)));
        scalar factor = std::pow(10.0, precision);
        scalar roundedTime = std::floor(time / writeInterval) * writeInterval;
        roundedTime = std::floor(roundedTime * factor + SMALL) / factor;

        if (mag(roundedTime - lastWrittenTime) > SMALL)
        {
            lastWrittenTime = roundedTime;
            Info << "Writing U, CO2 and T data for time " << roundedTime << endl;
            //extractFieldData("U", vector(0, -0.2, 0), vector(3.4, 3.3, 2.7), roundedTime);
            extractFieldData("CO2", vector(0, -0.2, 0), vector(3.4, 3.3, 2.7), roundedTime);
            extractFieldData("T", vector(0, -0.2, 0), vector(3.4, 3.3, 2.7), roundedTime);
            extractFieldData("alphat", vector(0, -0.2, 0), vector(3.4, 3.3, 2.7), roundedTime);
            extractFieldData("epsilon", vector(0, -0.2, 0), vector(3.4, 3.3, 2.7), roundedTime);
            extractFieldData("k", vector(0, -0.2, 0), vector(3.4, 3.3, 2.7), roundedTime);
            extractFieldData("nut", vector(0, -0.2, 0), vector(3.4, 3.3, 2.7), roundedTime);
            extractFieldData("p", vector(0, -0.2, 0), vector(3.4, 3.3, 2.7), roundedTime);
        }
    #};
}