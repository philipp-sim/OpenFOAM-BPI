/*--------------------------------*- C++ -*----------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     | Website:  https://openfoam.org
    \\  /    A nd           | Version:  12
     \\/     M anipulation  |
\*---------------------------------------------------------------------------*/
FoamFile
{
    format      ascii;
    class       dictionary;
    location    "system";
    object      functions;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

//#includeFunc scalarTransport(T, diffusivity=constant, D = 0.01)


CO2Eqn
{
    type            coded;
    libs ( "libutilityFunctionObjects.so" );
    writeControl    writeTime;

	codeInclude
    #{

		#include "volFields.H"
		#include "fvc.H"
		#include "fvm.H"
		#include "fvModels.H"
		#include "fvConstraints.H"

	#};

    codeExecute
    #{  

		auto ensureFieldExists = [&](const word& name, const dimensionSet& dims)
		{
			if (!mesh().objectRegistry::foundObject<volScalarField>(name))
			{
				Info << "Creating " << name << " field" << endl;
				auto* ptr = new volScalarField(
					IOobject(name, mesh().time().name(), mesh(), IOobject::READ_IF_PRESENT, IOobject::AUTO_WRITE),
					mesh(),
					dimensionedScalar(name, dims, 0.0)
				);
				mesh().objectRegistry::store(ptr);
			}
		};

		IOdictionary physicalProperties
		(
			IOobject
			(
				"physicalProperties",
				mesh().time().constant(),
				mesh(),
				IOobject::MUST_READ,
				IOobject::NO_WRITE
			)
		);

		ensureFieldExists("CO2", dimensionSet(0,0,0,0,0,0,0));
		ensureFieldExists("CO2relativdensity", dimensionSet(1,-3,0,0,0,0,0));

		volScalarField& CO2relativdensity = mesh().lookupObjectRef<volScalarField>("CO2relativdensity");
		volScalarField& CO2 = mesh().lookupObjectRef<volScalarField>("CO2");
		const volScalarField& T = mesh().lookupObject<volScalarField>("T");
		const volScalarField& rho = mesh().lookupObject<volScalarField>("rho");
		const surfaceScalarField& phi = mesh().lookupObject<surfaceScalarField>("phi");
		const Foam::fvModels& fvModels(Foam::fvModels::New(this->mesh()));
		const Foam::fvConstraints& fvConstraints(Foam::fvConstraints::New(this->mesh()));
		const dimensionedScalar D_CO2(physicalProperties.lookup("D_CO2"));

		const dimensionedScalar P("P", dimensionSet(1, -1, -2, 0, 0, 0, 0), 101325);// Pa standard atmosphere pressure
		const dimensionedScalar Rm("Rm", dimensionSet(1, 2, -2, -1 , -1, 0, 0), 8.314);// J/(mol*K) universal gas constant
		const dimensionedScalar M_C("M_C", dimensionSet(1, 0, 0, 0, -1, 0, 0), 12.0107e-3); // kg/mol
		const dimensionedScalar M_N("M_N", dimensionSet(1, 0, 0, 0, -1, 0, 0), 14.0067e-3); // kg/mol
		const dimensionedScalar M_O("M_O", dimensionSet(1, 0, 0, 0, -1, 0, 0), 15.9994e-3); // kg/mol
		const dimensionedScalar M_Ar("M_Ar", dimensionSet(1, 0, 0, 0, -1, 0, 0), 39.948e-3); // kg/mol  
		
		dimensionedScalar M_CO2 = M_C + 2 * M_O; // kg/mol
		volScalarField M_Air = M_N * 0.78 + M_O * (0.21 - CO2/1e6) + M_Ar * 0.01 + M_CO2 * (CO2/1e6); // kg/mol
		volScalarField Mol_co2_part =  M_CO2 * (CO2 / 1e6); // kg/mol Part from M_Air
		tmp<volScalarField> rho_mix = (M_Air * P) / (Rm * T); // kg/m³ mixture
		tmp<volScalarField> rho_co2 = (M_CO2 * P) / (Rm * T); // kg/m³ CO2
		CO2relativdensity = (P * Mol_co2_part) / (Rm * T); // kg/m³ CO2 mass from mixture 
        //volScalarField molFractionCO2 = CO2 / 1e6; // mol/mol
        //CO2relativdensity = (P * molFractionCO2) / (Rm * T); // mol/m³ CO2 concentration


		fvScalarMatrix CO2Eqn =
			fvm::ddt(rho, CO2relativdensity)
			+ fvm::div(phi, CO2relativdensity)
			- fvm::laplacian(rho_mix*D_CO2, CO2relativdensity)
			== fvModels.source(rho, CO2relativdensity);
			
		fvConstraints.constrain(CO2Eqn);
		CO2Eqn.relax();
		CO2Eqn.solve();
		volScalarField CO2_before = CO2relativdensity;
		fvConstraints.constrain(CO2relativdensity);
		CO2 = (CO2relativdensity*Rm*T*1e6)/(P*M_CO2); // ppm
        //CO2 = CO2relativdensity * Rm * T * 1e6 / P;

		const label nCells = returnReduce(CO2.internalField().size(), sumOp<label>());

		if (mesh().time().writeTime())
		{
			Info << "D_CO2: " << D_CO2.value() << endl;
			Info << "Cell count: " << nCells << endl;
			Info << "CO2relativdensity avg: " << gSum(CO2relativdensity) / nCells << endl;
			Info << "CO2 avg: " << gSum(CO2) / nCells << endl;
		}
    #};
}



// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

Humidity
{
    type	coded;
    libs	("libutilityFunctionObjects.so");
    writeControl    writeTime;

    codeInclude
    #{
		#include "volFields.H"
		#include "fvc.H"
		#include "fvm.H"
		#include "fvModels.H"
		#include "fvConstraints.H"
    #};

    codeExecute
    #{
    	auto ensureFieldExists = [&](const word& name, const dimensionSet& dims)
		{
			if (!mesh().objectRegistry::foundObject<volScalarField>(name))
			{
				Info << "Creating " << name << " field" << endl;
				auto* ptr = new volScalarField(
					IOobject(name, mesh().time().name(), mesh(), IOobject::READ_IF_PRESENT, IOobject::AUTO_WRITE),
					mesh(),
					dimensionedScalar(name, dims, 0.0)
				);
				mesh().objectRegistry::store(ptr);
			}
		};
        
        IOdictionary physicalProperties
		(
			IOobject
			(
				"physicalProperties",
				mesh().time().constant(),
				mesh(),
				IOobject::MUST_READ,
				IOobject::NO_WRITE
			)
		);

    	//const volScalarField& T = mesh().lookupObject<volScalarField>("T");
        volScalarField& T = mesh().lookupObjectRef<volScalarField>("T");
        const volVectorField& U = mesh().lookupObject<volVectorField>("U");
        volScalarField& CO2 = mesh().lookupObjectRef<volScalarField>("CO2");
		const Foam::fvModels& fvModels(Foam::fvModels::New(this->mesh()));
		const Foam::fvConstraints& fvConstraints(Foam::fvConstraints::New(this->mesh()));
		const dimensionedScalar D_hum(physicalProperties.lookup("D_hum"));
    	const dimensionedScalar P("P", dimensionSet(1, -1, -2, 0, 0, 0, 0), 101325);// Pa standard atmosphere pressure 
        const dimensionedScalar T0("T0", T.dimensions(), 273.15);
        volScalarField T_Celsius = T - T0;
        volScalarField p_sat = dimensionedScalar("Ptet", P.dimensions(), 610.78) * exp((17.27 * T_Celsius) / (T_Celsius + dimensionedScalar("T0", T.dimensions(), 273.15))); 
        //p_sat is Pa = 610.78 or kPa = 0.61078
        volScalarField q_s = ((0.622 * p_sat) / (P - p_sat));

        ensureFieldExists("relHumidity", dimensionSet(0,0,0,0,0,0,0));
        volScalarField& relHumidity = mesh().lookupObjectRef<volScalarField>("relHumidity");
        ensureFieldExists("specificHumidity", dimensionSet(0,0,0,0,0,0,0));
        volScalarField& specificHumidity = mesh().lookupObjectRef<volScalarField>("specificHumidity");
        relHumidity = specificHumidity / q_s;

        //calcualte rho_humair 
		const dimensionedScalar Rm("Rm", dimensionSet(1, 2, -2, -1 , -1, 0, 0), 8.314);// J/(mol*K) universal gas constant
		const dimensionedScalar M_C("M_C", dimensionSet(1, 0, 0, 0, -1, 0, 0), 12.0107e-3); // kg/mol
		const dimensionedScalar M_N("M_N", dimensionSet(1, 0, 0, 0, -1, 0, 0), 14.0067e-3); // kg/mol
		const dimensionedScalar M_O("M_O", dimensionSet(1, 0, 0, 0, -1, 0, 0), 15.9994e-3); // kg/mol
		const dimensionedScalar M_Ar("M_Ar", dimensionSet(1, 0, 0, 0, -1, 0, 0), 39.948e-3); // kg/mol  
        const dimensionedScalar M_H("M_H", dimensionSet(1, 0, 0, 0, -1, 0, 0), 2.016e-3); // kg/mol
        const dimensionedScalar Rd("Rd", dimensionSet(0, 2, -2, -1 , 0, 0, 0), 287.058);// J/(kg·K) specific gas constant for dry air
        const dimensionedScalar Rv("Rv", dimensionSet(0, 2, -2, -1 , 0, 0, 0), 461.495);// J/(kg·K) specific gas constant for water vapor
        dimensionedScalar M_CO2 = M_C + 2 * M_O; // kg/mol Molmass
        dimensionedScalar M_H2O = 2 * M_H + M_O; // kg/mol Molmass
		volScalarField M_Air = M_N * 0.78 + M_O * (0.21 - CO2/1e6) + M_Ar * 0.01 + M_CO2 * (CO2/1e6); // kg/mol Molmass
        volScalarField pv = p_sat * relHumidity; //Pa partial pressure of water vapor
        tmp<volScalarField> pd = P - pv; // Pa partial pressure of dry air

        volScalarField rho_humair
        (
            IOobject
            (
                "rho_humair",
				mesh().time().constant(),
				mesh(),
                IOobject::NO_READ,
                IOobject::NO_WRITE
            ),
            (pd*M_Air + pv*M_H2O) / (Rm * T)
        );

        surfaceScalarField phi_hum = fvc::interpolate(rho_humair) * fvc::interpolate(U) & mesh().Sf(); // phi = rho_humair * U

        fvScalarMatrix humEqn =
			fvm::ddt(rho_humair, specificHumidity)
            + fvm::div(phi_hum, specificHumidity, "div(phi,specificHumidity)")
			- fvm::laplacian(rho_humair*D_hum, specificHumidity)
			== fvModels.source(rho_humair, specificHumidity);
	
		fvConstraints.constrain(humEqn);
		humEqn.relax();
		humEqn.solve();
        
        relHumidity = specificHumidity / q_s; // update rel
        label wallPatchID = -1;
        forAll(mesh().boundary(), patchI)
        {
            if (mesh().boundary()[patchI].name() == "walls")
            {
                wallPatchID = patchI;
                break;
            }
        }
        if (wallPatchID == -1)
        {
            FatalErrorInFunction << "Patch 'walls' not found!" << exit(FatalError);
        }
        
        ensureFieldExists("condensate", dimensionSet(1,-3,0,0,0,0,0));
        volScalarField& condensate = mesh().lookupObjectRef<volScalarField>("condensate");

        const labelList& wallCells = mesh().boundary()[wallPatchID].faceCells();
        forAll(wallCells, j)
        {
            label cellI = wallCells[j];

            if (relHumidity[cellI] > 1.0)
            {
                scalar excessRH = relHumidity[cellI] - 1.0;
                scalar delta_q = excessRH * q_s[cellI];                  // [kg/kg]
                scalar delta_mass = delta_q * rho_humair[cellI];         // [kg/m³]

                condensate[cellI] += delta_mass;                         
                relHumidity[cellI] = 1.0;                                
                specificHumidity[cellI] = q_s[cellI];                    
            }
        }
        


        /*
        // Condensation if relHumidity > 1.0
        volScalarField excessRH = max(relHumidity - scalar(1.0), scalar(0.0));
        volScalarField delta_q = excessRH * q_s; // [g/kg]
        volScalarField delta_mass = delta_q * rho_humair; // [g/m³], actual condensed water mass
        
        ensureFieldExists("condensate", dimensionSet(1,-3,0,0,0,0,0));
        volScalarField& condensate = mesh().lookupObjectRef<volScalarField>("condensate");
        condensate += delta_mass; // Add to stored condensate
        relHumidity = min(relHumidity, scalar(1.0)); // Cap RH at 100%
        specificHumidity = relHumidity * q_s; // Update SH after condensation


        const dimensionedScalar L_v("L_v", dimensionSet(0, 2, -2, 0, 0, 0, 0), 2.5e6); // z. B. 2.5 MJ/kg
        const dimensionedScalar cp_air("cp_air", dimensionSet(0, 2, -2, -1, 0, 0, 0), 1005.0); // J/(kg·K)
        volScalarField delta_T = (delta_mass * L_v) / (rho_humair * cp_air);
        T += delta_T;
        T.write();


        Info << "Max delta_T durch Kondensation: " << gMax(delta_T) << " K" << endl;
        Info << "gMax(relHumidity): " << gMax(relHumidity) << endl;
        Info << "gMax(delta_mass): " << gMax(delta_mass) << " kg/m3" << endl;
        Info << "gMax(delta_T): " << gMax(delta_T) << " K" << endl;
        Info << "gMax(T): " << gMax(T) << " K" << endl;

        */


    #};
}

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //



DataExtract
{
    type    coded;
    libs    ("libutilityFunctionObjects.so");
    name    DataExtract;

    codeInclude
    #{
        #include "fvMesh.H"
        #include "volFields.H"
        #include "OSspecific.H"
        #include "IOobjectList.H"
        #include "OFstream.H"
        #include <thread>
        #include <chrono>
    #};

    codeLibs
    #{
        -lOpenFOAM -lfiniteVolume
    #};

    codeExecute
    #{
        auto extractFieldData = [&](const word& fieldName, const vector& lower, const vector& upper, const scalar& roundedTime)
        {
            const fvMesh& mesh = this->mesh();
            const pointField& centres = mesh.C();
            bool isParallel = (Pstream::parRun() && Pstream::nProcs() > 1);

            fileName mergedDir = mesh.time().globalPath() / "postProcess" / fieldName;
            mkDir(mergedDir);
            fileName mergedOutputPath = mergedDir / "Data";
            if (roundedTime == 0 && isFile(mergedOutputPath))
            {
                std::remove(mergedOutputPath.c_str());
            }

            fileName procOutputPath;
            if (isParallel)
            {
                procOutputPath = mesh.time().path() / (fieldName + "_" + Foam::name(roundedTime) + "_proc" + Foam::name(Pstream::myProcNo()));
            }
            else
            {
                procOutputPath = mergedDir / Foam::name(roundedTime);
            }

            if (isFile(procOutputPath))
            {
                std::remove(procOutputPath.c_str());
            }

            std::ostringstream buffer;

            if (mesh.foundObject<volScalarField>(fieldName))
            {
                const volScalarField& field = mesh.lookupObject<volScalarField>(fieldName);
                buffer << "x,y,z," << fieldName << "\n";

                forAll(field, cellI)
                {
                    const point& p = centres[cellI];
                    if ((p.x() >= lower.x() && p.x() <= upper.x()) &&
                        (p.y() >= lower.y() && p.y() <= upper.y()) &&
                        (p.z() >= lower.z() && p.z() <= upper.z()))
                    {
                        scalar val = field[cellI];
                        buffer << p.x() << "," << p.y() << "," << p.z() << "," << val << "\n";
                    }
                }
            }
            else if (mesh.foundObject<volVectorField>(fieldName))
            {
                const volVectorField& field = mesh.lookupObject<volVectorField>(fieldName);
                buffer << "x,y,z," << fieldName << "_x," << fieldName << "_y," << fieldName << "_z," << fieldName << "_mag\n";

                forAll(field, cellI)
                {
                    const point& p = centres[cellI];
                    if ((p.x() >= lower.x() && p.x() <= upper.x()) &&
                        (p.y() >= lower.y() && p.y() <= upper.y()) &&
                        (p.z() >= lower.z() && p.z() <= upper.z()))
                    {
                        const vector& val = field[cellI];
                        buffer << p.x() << "," << p.y() << "," << p.z() << ","
                               << val.x() << "," << val.y() << "," << val.z() << ","
                               << mag(val) << "\n";
                    }
                }
            }
            else
            {
                Info << "Field " << fieldName << " not found or unsupported type." << endl;
                return true;
            }

            std::ofstream output(procOutputPath.c_str());
            output << buffer.str();
            output.close();

            Info << fieldName << " values written to " << procOutputPath << endl;

            if (isParallel)
            {
                scalar dummy = 0;
                Pstream::scatter(dummy);

                if (Pstream::myProcNo() == 0)
                {
                    std::ofstream merged(mergedOutputPath.c_str(), std::ios::app);
                    merged << "Timestep" << Foam::name(roundedTime) << "\n";

                    for (int procNo = 0; procNo < Pstream::nProcs(); ++procNo)
                    {
                        fileName procDir = mesh.time().globalPath() / ("processor" + Foam::name(procNo));
                        fileName filePath = procDir / (fieldName + "_" + Foam::name(roundedTime) + "_proc" + Foam::name(procNo));
                        const int maxWaitMs = 1000;
                        bool fileAvailable = false;
                        for (int waitMs = 0; waitMs < maxWaitMs; ++waitMs)
                        {
                            if (isFile(filePath))
                            {
                                fileAvailable = true;
                                break;
                            }
                            std::this_thread::sleep_for(std::chrono::milliseconds(1));
                        }

                        if (fileAvailable)
                        {
                            std::ifstream fin(filePath.c_str());
                            std::string line;
                            bool firstLine = true;
                            while (std::getline(fin, line))
                            {
                                if (firstLine) { firstLine = false; continue; }
                                merged << "\"" << line << "\"\n";
                            }
                            fin.close();
                            std::remove(filePath.c_str());
                        }
                        else
                        {
                            Info << "Missing file from processor" << procNo << ": " << filePath << endl;
                        }
                    }

                    merged.close();
                    Info << "Appended data block for time " << roundedTime << " to " << mergedOutputPath << endl;
                }
            }
            else
            {
                std::ifstream fin(procOutputPath.c_str());
                std::ofstream merged(mergedOutputPath.c_str(), std::ios::app);
                std::string line;
                bool firstLine = true;

                merged << Foam::name(roundedTime) << "\n";

                while (std::getline(fin, line))
                {
                    if (firstLine) { firstLine = false; continue; }
                    merged << "\"" << line << "\"\n";
                }

                fin.close();
                merged.close();
                std::remove(procOutputPath.c_str());
                Info << "Appended data block for time " << roundedTime << " to " << mergedOutputPath << " (serial mode)" << endl;
            }

            return true;
        };

        static scalar lastWrittenTime = -1;
        scalar writeInterval = 1; 
        scalar time = mesh().time().value();
        int precision = std::max(0, int(-std::floor(std::log10(writeInterval) + SMALL)));
        scalar factor = std::pow(10.0, precision);
        scalar roundedTime = std::floor(time / writeInterval) * writeInterval;
        roundedTime = std::floor(roundedTime * factor + SMALL) / factor;

        if (mag(roundedTime - lastWrittenTime) > SMALL)
        {
            lastWrittenTime = roundedTime;
            Info << "Writing U, CO2 and T data for time " << roundedTime << endl;
            extractFieldData("U", vector(0, -0.2, 0), vector(4, 6.2, 3), roundedTime);
            extractFieldData("CO2", vector(0, -0.2, 0), vector(4, 6.2, 3), roundedTime);
            extractFieldData("T", vector(0, -0.2, 0), vector(4, 6.2, 3), roundedTime);
            //extractFieldData("T", vector(1,1,1), vector(1.5,1.5,1.5), roundedTime);
        }
    #};
}